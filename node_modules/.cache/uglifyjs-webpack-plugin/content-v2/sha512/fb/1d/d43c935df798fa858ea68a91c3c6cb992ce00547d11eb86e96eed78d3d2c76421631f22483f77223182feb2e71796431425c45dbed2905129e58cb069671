{"map":"{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\"}","code":"webpackHotUpdate(2,{55:function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(Buffer) {// var fs = require('fs');\\n\\nvar _ = __webpack_require__(35)._;\\nvar Tokenizer = __webpack_require__(60);\\nvar tokenizer = new Tokenizer();\\n\\nvar stopwords_en = __webpack_require__(65);\\nvar stopwords_vi = __webpack_require__(83);\\n\\nvar stopwords = _.union(stopwords_en, stopwords_vi);\\n\\nfunction buildDocument(text, key) {\\n    var stopOut;\\n\\n    if (typeof text === 'string') {\\n        text = tokenizer.tokenize(text.toLowerCase());\\n        stopOut = true;\\n    } else if (!_.isArray(text)) {\\n        stopOut = false;\\n        return text;\\n    }\\n\\n    return text.reduce(function(document, term) {\\n        if (typeof document[term] === 'function') document[term] = 0;\\n        if (!stopOut || stopwords.indexOf(term) < 0)\\n            document[term] = (document[term] ? document[term] + 1 : 1);\\n        return document;\\n    }, {\\n        __key: key\\n    });\\n}\\n\\nfunction tf(term, document) {\\n    return document[term] ? document[term] : 0;\\n}\\n\\nfunction documentHasTerm(term, document) {\\n    return document[term] && document[term] > 0;\\n}\\n\\nfunction TfIdf(deserialized) {\\n    if (deserialized)\\n        this.documents = deserialized.documents;\\n    else\\n        this.documents = [];\\n\\n    this._idfCache = {};\\n}\\n\\n// backwards compatibility for < node 0.10\\nfunction isEncoding(encoding) {\\n    if (typeof Buffer.isEncoding !== 'undefined')\\n        return Buffer.isEncoding(encoding);\\n    switch ((encoding + '').toLowerCase()) {\\n        case 'hex':\\n        case 'utf8':\\n        case 'utf-8':\\n        case 'ascii':\\n        case 'binary':\\n        case 'base64':\\n        case 'ucs2':\\n        case 'ucs-2':\\n        case 'utf16le':\\n        case 'utf-16le':\\n        case 'raw':\\n            return true;\\n    }\\n    return false;\\n}\\n\\nmodule.exports = TfIdf;\\nTfIdf.tf = tf;\\n\\nTfIdf.prototype.idf = function(term, force) {\\n\\n    // Lookup the term in the New term-IDF caching,\\n    // this will cut search times down exponentially on large document sets.\\n    if (this._idfCache[term] && this._idfCache.hasOwnProperty(term) && force !== true)\\n        return this._idfCache[term];\\n\\n    var docsWithTerm = this.documents.reduce(function(count, document) {\\n        return count + (documentHasTerm(term, document) ? 1 : 0);\\n    }, 0);\\n\\n    var idf = 1 + Math.log((this.documents.length) / (1 + docsWithTerm));\\n\\n    // Add the idf to the term cache and return it\\n    this._idfCache[term] = idf;\\n    return idf;\\n};\\n\\n// If restoreCache is set to true, all terms idf scores currently cached will be recomputed.\\n// Otherwise, the cache will just be wiped clean\\nTfIdf.prototype.addDocument = function(document, key, restoreCache) {\\n    this.documents.push(buildDocument(document, key));\\n\\n    // make sure the cache is invalidated when new documents arrive\\n    if (restoreCache === true) {\\n        for (var term in this._idfCache) {\\n            // invoking idf with the force option set will\\n            // force a recomputation of the idf, and it will\\n            // automatically refresh the cache value.\\n            this.idf(term, true);\\n        }\\n    } else {\\n        this._idfCache = {};\\n    }\\n};\\n\\n// If restoreCache is set to true, all terms idf scores currently cached will be recomputed.\\n// Otherwise, the cache will just be wiped clean\\n// TfIdf.prototype.addFileSync = function(path, encoding, key, restoreCache) {\\n//     if (!encoding)\\n//         encoding = 'utf8';\\n//     if (!isEncoding(encoding))\\n//         throw new Error('Invalid encoding: ' + encoding);\\n//\\n//     var document = fs.readFileSync(path, encoding);\\n//     this.documents.push(buildDocument(document, key));\\n//\\n//     // make sure the cache is invalidated when new documents arrive\\n//     if (restoreCache === true) {\\n//         for (var term in this._idfCache) {\\n//             // invoking idf with the force option set will\\n//             // force a recomputation of the idf, and it will\\n//             // automatically refresh the cache value.\\n//             this.idf(term, true);\\n//         }\\n//     } else {\\n//         this._idfCache = {};\\n//     }\\n// };\\n\\nTfIdf.prototype.tfidf = function(terms, d) {\\n    var _this = this;\\n\\n    if (!_.isArray(terms))\\n        terms = tokenizer.tokenize(terms.toString().toLowerCase());\\n\\n    return terms.reduce(function(value, term) {\\n        var idf = _this.idf(term);\\n        idf = idf === Infinity ? 0 : idf;\\n        return value + (tf(term, _this.documents[d]) * idf);\\n    }, 0.0);\\n};\\n\\nTfIdf.prototype.listTerms = function(d) {\\n    var terms = [];\\n\\n    for (var term in this.documents[d]) {\\n        if (term != '__key')\\n            terms.push({\\n                term: term,\\n                tfidf: this.tfidf(term, d)\\n            });\\n    }\\n\\n    return terms.sort(function(x, y) {\\n        return y.tfidf - x.tfidf;\\n    });\\n};\\n\\nTfIdf.prototype.tfidfs = function(terms, callback) {\\n    var tfidfs = new Array(this.documents.length);\\n\\n    for (var i = 0; i < this.documents.length; i++) {\\n        tfidfs[i] = this.tfidf(terms, i);\\n\\n        if (callback)\\n            callback(i, tfidfs[i], this.documents[i].__key);\\n    }\\n\\n    return tfidfs;\\n};\\n\\n// Define a tokenizer other than the default \\\"WordTokenizer\\\"\\nTfIdf.prototype.setTokenizer = function(t) {\\n    if (!_.isFunction(t.tokenize))\\n        throw new Error('Expected a valid Tokenizer');\\n    tokenizer = t;\\n};\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(56).Buffer))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS10ZmlkZi9saWIvdGZpZGYvaW5kZXguanM/Mjk5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG52YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpLl87XG52YXIgVG9rZW5pemVyID0gcmVxdWlyZSgnbm9kZS12bnRva2VuaXplcicpO1xudmFyIHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoKTtcblxudmFyIHN0b3B3b3Jkc19lbiA9IHJlcXVpcmUoJy4vbW9kZWwvc3RvcHdvcmRzLWVuJyk7XG52YXIgc3RvcHdvcmRzX3ZpID0gcmVxdWlyZSgndmlldG5hbWVzZS1zdG9wd29yZHMnKTtcblxudmFyIHN0b3B3b3JkcyA9IF8udW5pb24oc3RvcHdvcmRzX2VuLCBzdG9wd29yZHNfdmkpO1xuXG5mdW5jdGlvbiBidWlsZERvY3VtZW50KHRleHQsIGtleSkge1xuICAgIHZhciBzdG9wT3V0O1xuXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0ZXh0ID0gdG9rZW5pemVyLnRva2VuaXplKHRleHQudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHN0b3BPdXQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIV8uaXNBcnJheSh0ZXh0KSkge1xuICAgICAgICBzdG9wT3V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0LnJlZHVjZShmdW5jdGlvbihkb2N1bWVudCwgdGVybSkge1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50W3Rlcm1dID09PSAnZnVuY3Rpb24nKSBkb2N1bWVudFt0ZXJtXSA9IDA7XG4gICAgICAgIGlmICghc3RvcE91dCB8fCBzdG9wd29yZHMuaW5kZXhPZih0ZXJtKSA8IDApXG4gICAgICAgICAgICBkb2N1bWVudFt0ZXJtXSA9IChkb2N1bWVudFt0ZXJtXSA/IGRvY3VtZW50W3Rlcm1dICsgMSA6IDEpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfSwge1xuICAgICAgICBfX2tleToga2V5XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHRmKHRlcm0sIGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50W3Rlcm1dID8gZG9jdW1lbnRbdGVybV0gOiAwO1xufVxuXG5mdW5jdGlvbiBkb2N1bWVudEhhc1Rlcm0odGVybSwgZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRbdGVybV0gJiYgZG9jdW1lbnRbdGVybV0gPiAwO1xufVxuXG5mdW5jdGlvbiBUZklkZihkZXNlcmlhbGl6ZWQpIHtcbiAgICBpZiAoZGVzZXJpYWxpemVkKVxuICAgICAgICB0aGlzLmRvY3VtZW50cyA9IGRlc2VyaWFsaXplZC5kb2N1bWVudHM7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLmRvY3VtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5faWRmQ2FjaGUgPSB7fTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIDwgbm9kZSAwLjEwXG5mdW5jdGlvbiBpc0VuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBCdWZmZXIuaXNFbmNvZGluZyAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgc3dpdGNoICgoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdoZXgnOlxuICAgICAgICBjYXNlICd1dGY4JzpcbiAgICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgICBjYXNlICd1Y3MtMic6XG4gICAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIGNhc2UgJ3Jhdyc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRmSWRmO1xuVGZJZGYudGYgPSB0ZjtcblxuVGZJZGYucHJvdG90eXBlLmlkZiA9IGZ1bmN0aW9uKHRlcm0sIGZvcmNlKSB7XG5cbiAgICAvLyBMb29rdXAgdGhlIHRlcm0gaW4gdGhlIE5ldyB0ZXJtLUlERiBjYWNoaW5nLFxuICAgIC8vIHRoaXMgd2lsbCBjdXQgc2VhcmNoIHRpbWVzIGRvd24gZXhwb25lbnRpYWxseSBvbiBsYXJnZSBkb2N1bWVudCBzZXRzLlxuICAgIGlmICh0aGlzLl9pZGZDYWNoZVt0ZXJtXSAmJiB0aGlzLl9pZGZDYWNoZS5oYXNPd25Qcm9wZXJ0eSh0ZXJtKSAmJiBmb3JjZSAhPT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkZkNhY2hlW3Rlcm1dO1xuXG4gICAgdmFyIGRvY3NXaXRoVGVybSA9IHRoaXMuZG9jdW1lbnRzLnJlZHVjZShmdW5jdGlvbihjb3VudCwgZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50ICsgKGRvY3VtZW50SGFzVGVybSh0ZXJtLCBkb2N1bWVudCkgPyAxIDogMCk7XG4gICAgfSwgMCk7XG5cbiAgICB2YXIgaWRmID0gMSArIE1hdGgubG9nKCh0aGlzLmRvY3VtZW50cy5sZW5ndGgpIC8gKDEgKyBkb2NzV2l0aFRlcm0pKTtcblxuICAgIC8vIEFkZCB0aGUgaWRmIHRvIHRoZSB0ZXJtIGNhY2hlIGFuZCByZXR1cm4gaXRcbiAgICB0aGlzLl9pZGZDYWNoZVt0ZXJtXSA9IGlkZjtcbiAgICByZXR1cm4gaWRmO1xufTtcblxuLy8gSWYgcmVzdG9yZUNhY2hlIGlzIHNldCB0byB0cnVlLCBhbGwgdGVybXMgaWRmIHNjb3JlcyBjdXJyZW50bHkgY2FjaGVkIHdpbGwgYmUgcmVjb21wdXRlZC5cbi8vIE90aGVyd2lzZSwgdGhlIGNhY2hlIHdpbGwganVzdCBiZSB3aXBlZCBjbGVhblxuVGZJZGYucHJvdG90eXBlLmFkZERvY3VtZW50ID0gZnVuY3Rpb24oZG9jdW1lbnQsIGtleSwgcmVzdG9yZUNhY2hlKSB7XG4gICAgdGhpcy5kb2N1bWVudHMucHVzaChidWlsZERvY3VtZW50KGRvY3VtZW50LCBrZXkpKTtcblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgY2FjaGUgaXMgaW52YWxpZGF0ZWQgd2hlbiBuZXcgZG9jdW1lbnRzIGFycml2ZVxuICAgIGlmIChyZXN0b3JlQ2FjaGUgPT09IHRydWUpIHtcbiAgICAgICAgZm9yICh2YXIgdGVybSBpbiB0aGlzLl9pZGZDYWNoZSkge1xuICAgICAgICAgICAgLy8gaW52b2tpbmcgaWRmIHdpdGggdGhlIGZvcmNlIG9wdGlvbiBzZXQgd2lsbFxuICAgICAgICAgICAgLy8gZm9yY2UgYSByZWNvbXB1dGF0aW9uIG9mIHRoZSBpZGYsIGFuZCBpdCB3aWxsXG4gICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggdGhlIGNhY2hlIHZhbHVlLlxuICAgICAgICAgICAgdGhpcy5pZGYodGVybSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pZGZDYWNoZSA9IHt9O1xuICAgIH1cbn07XG5cbi8vIElmIHJlc3RvcmVDYWNoZSBpcyBzZXQgdG8gdHJ1ZSwgYWxsIHRlcm1zIGlkZiBzY29yZXMgY3VycmVudGx5IGNhY2hlZCB3aWxsIGJlIHJlY29tcHV0ZWQuXG4vLyBPdGhlcndpc2UsIHRoZSBjYWNoZSB3aWxsIGp1c3QgYmUgd2lwZWQgY2xlYW5cbi8vIFRmSWRmLnByb3RvdHlwZS5hZGRGaWxlU3luYyA9IGZ1bmN0aW9uKHBhdGgsIGVuY29kaW5nLCBrZXksIHJlc3RvcmVDYWNoZSkge1xuLy8gICAgIGlmICghZW5jb2RpbmcpXG4vLyAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuLy8gICAgIGlmICghaXNFbmNvZGluZyhlbmNvZGluZykpXG4vLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbi8vXG4vLyAgICAgdmFyIGRvY3VtZW50ID0gZnMucmVhZEZpbGVTeW5jKHBhdGgsIGVuY29kaW5nKTtcbi8vICAgICB0aGlzLmRvY3VtZW50cy5wdXNoKGJ1aWxkRG9jdW1lbnQoZG9jdW1lbnQsIGtleSkpO1xuLy9cbi8vICAgICAvLyBtYWtlIHN1cmUgdGhlIGNhY2hlIGlzIGludmFsaWRhdGVkIHdoZW4gbmV3IGRvY3VtZW50cyBhcnJpdmVcbi8vICAgICBpZiAocmVzdG9yZUNhY2hlID09PSB0cnVlKSB7XG4vLyAgICAgICAgIGZvciAodmFyIHRlcm0gaW4gdGhpcy5faWRmQ2FjaGUpIHtcbi8vICAgICAgICAgICAgIC8vIGludm9raW5nIGlkZiB3aXRoIHRoZSBmb3JjZSBvcHRpb24gc2V0IHdpbGxcbi8vICAgICAgICAgICAgIC8vIGZvcmNlIGEgcmVjb21wdXRhdGlvbiBvZiB0aGUgaWRmLCBhbmQgaXQgd2lsbFxuLy8gICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSByZWZyZXNoIHRoZSBjYWNoZSB2YWx1ZS5cbi8vICAgICAgICAgICAgIHRoaXMuaWRmKHRlcm0sIHRydWUpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgdGhpcy5faWRmQ2FjaGUgPSB7fTtcbi8vICAgICB9XG4vLyB9O1xuXG5UZklkZi5wcm90b3R5cGUudGZpZGYgPSBmdW5jdGlvbih0ZXJtcywgZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIV8uaXNBcnJheSh0ZXJtcykpXG4gICAgICAgIHRlcm1zID0gdG9rZW5pemVyLnRva2VuaXplKHRlcm1zLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSk7XG5cbiAgICByZXR1cm4gdGVybXMucmVkdWNlKGZ1bmN0aW9uKHZhbHVlLCB0ZXJtKSB7XG4gICAgICAgIHZhciBpZGYgPSBfdGhpcy5pZGYodGVybSk7XG4gICAgICAgIGlkZiA9IGlkZiA9PT0gSW5maW5pdHkgPyAwIDogaWRmO1xuICAgICAgICByZXR1cm4gdmFsdWUgKyAodGYodGVybSwgX3RoaXMuZG9jdW1lbnRzW2RdKSAqIGlkZik7XG4gICAgfSwgMC4wKTtcbn07XG5cblRmSWRmLnByb3RvdHlwZS5saXN0VGVybXMgPSBmdW5jdGlvbihkKSB7XG4gICAgdmFyIHRlcm1zID0gW107XG5cbiAgICBmb3IgKHZhciB0ZXJtIGluIHRoaXMuZG9jdW1lbnRzW2RdKSB7XG4gICAgICAgIGlmICh0ZXJtICE9ICdfX2tleScpXG4gICAgICAgICAgICB0ZXJtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0ZXJtOiB0ZXJtLFxuICAgICAgICAgICAgICAgIHRmaWRmOiB0aGlzLnRmaWRmKHRlcm0sIGQpXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVybXMuc29ydChmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB5LnRmaWRmIC0geC50ZmlkZjtcbiAgICB9KTtcbn07XG5cblRmSWRmLnByb3RvdHlwZS50ZmlkZnMgPSBmdW5jdGlvbih0ZXJtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgdGZpZGZzID0gbmV3IEFycmF5KHRoaXMuZG9jdW1lbnRzLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZG9jdW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRmaWRmc1tpXSA9IHRoaXMudGZpZGYodGVybXMsIGkpO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgIGNhbGxiYWNrKGksIHRmaWRmc1tpXSwgdGhpcy5kb2N1bWVudHNbaV0uX19rZXkpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZmlkZnM7XG59O1xuXG4vLyBEZWZpbmUgYSB0b2tlbml6ZXIgb3RoZXIgdGhhbiB0aGUgZGVmYXVsdCBcIldvcmRUb2tlbml6ZXJcIlxuVGZJZGYucHJvdG90eXBlLnNldFRva2VuaXplciA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbih0LnRva2VuaXplKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHZhbGlkIFRva2VuaXplcicpO1xuICAgIHRva2VuaXplciA9IHQ7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///55\\n\")},83:function(module,exports,__webpack_require__){\"use strict\";eval(\"/* WEBPACK VAR INJECTION */(function(__dirname) {\\n\\nvar fs = __webpack_require__(34);\\nvar path = __webpack_require__(84);\\n\\nvar words = fs.readFileSync(path.join(__dirname, './vietnamese-stopwords.txt'), 'utf8');\\n\\nmodule.exports = words.split('\\\\n').map(function(word) {\\n        return (word || '').trim();\\n}).filter(function(word) {\\n        return word !== false && word.length > 0;\\n})\\n\\n/* WEBPACK VAR INJECTION */}.call(this, \\\"/\\\"))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmlldG5hbWVzZS1zdG9wd29yZHMvaW5kZXguanM/ZmIwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxudmFyIHdvcmRzID0gZnMucmVhZEZpbGVTeW5jKHBhdGguam9pbihfX2Rpcm5hbWUsICcuL3ZpZXRuYW1lc2Utc3RvcHdvcmRzLnR4dCcpLCAndXRmOCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHdvcmRzLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24od29yZCkge1xuICAgICAgICByZXR1cm4gKHdvcmQgfHwgJycpLnRyaW0oKTtcbn0pLmZpbHRlcihmdW5jdGlvbih3b3JkKSB7XG4gICAgICAgIHJldHVybiB3b3JkICE9PSBmYWxzZSAmJiB3b3JkLmxlbmd0aCA+IDA7XG59KVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///83\\n\")},84:function(module,exports,__webpack_require__){eval(\"/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n// resolves . and .. elements in a path array with directory names there\\n// must be no slashes, empty elements, or device names (c:\\\\) in the array\\n// (so also no leading and trailing slashes - it does not distinguish\\n// relative and absolute paths)\\nfunction normalizeArray(parts, allowAboveRoot) {\\n  // if the path tries to go above the root, `up` ends up > 0\\n  var up = 0;\\n  for (var i = parts.length - 1; i >= 0; i--) {\\n    var last = parts[i];\\n    if (last === '.') {\\n      parts.splice(i, 1);\\n    } else if (last === '..') {\\n      parts.splice(i, 1);\\n      up++;\\n    } else if (up) {\\n      parts.splice(i, 1);\\n      up--;\\n    }\\n  }\\n\\n  // if the path is allowed to go above the root, restore leading ..s\\n  if (allowAboveRoot) {\\n    for (; up--; up) {\\n      parts.unshift('..');\\n    }\\n  }\\n\\n  return parts;\\n}\\n\\n// Split a filename into [root, dir, basename, ext], unix version\\n// 'root' is just a slash, or nothing.\\nvar splitPathRe =\\n    /^(\\\\/?|)([\\\\s\\\\S]*?)((?:\\\\.{1,2}|[^\\\\/]+?|)(\\\\.[^.\\\\/]*|))(?:[\\\\/]*)$/;\\nvar splitPath = function(filename) {\\n  return splitPathRe.exec(filename).slice(1);\\n};\\n\\n// path.resolve([from ...], to)\\n// posix version\\nexports.resolve = function() {\\n  var resolvedPath = '',\\n      resolvedAbsolute = false;\\n\\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\\n    var path = (i >= 0) ? arguments[i] : process.cwd();\\n\\n    // Skip empty and invalid entries\\n    if (typeof path !== 'string') {\\n      throw new TypeError('Arguments to path.resolve must be strings');\\n    } else if (!path) {\\n      continue;\\n    }\\n\\n    resolvedPath = path + '/' + resolvedPath;\\n    resolvedAbsolute = path.charAt(0) === '/';\\n  }\\n\\n  // At this point the path should be resolved to a full absolute path, but\\n  // handle relative paths to be safe (might happen when process.cwd() fails)\\n\\n  // Normalize the path\\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\\n    return !!p;\\n  }), !resolvedAbsolute).join('/');\\n\\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\\n};\\n\\n// path.normalize(path)\\n// posix version\\nexports.normalize = function(path) {\\n  var isAbsolute = exports.isAbsolute(path),\\n      trailingSlash = substr(path, -1) === '/';\\n\\n  // Normalize the path\\n  path = normalizeArray(filter(path.split('/'), function(p) {\\n    return !!p;\\n  }), !isAbsolute).join('/');\\n\\n  if (!path && !isAbsolute) {\\n    path = '.';\\n  }\\n  if (path && trailingSlash) {\\n    path += '/';\\n  }\\n\\n  return (isAbsolute ? '/' : '') + path;\\n};\\n\\n// posix version\\nexports.isAbsolute = function(path) {\\n  return path.charAt(0) === '/';\\n};\\n\\n// posix version\\nexports.join = function() {\\n  var paths = Array.prototype.slice.call(arguments, 0);\\n  return exports.normalize(filter(paths, function(p, index) {\\n    if (typeof p !== 'string') {\\n      throw new TypeError('Arguments to path.join must be strings');\\n    }\\n    return p;\\n  }).join('/'));\\n};\\n\\n\\n// path.relative(from, to)\\n// posix version\\nexports.relative = function(from, to) {\\n  from = exports.resolve(from).substr(1);\\n  to = exports.resolve(to).substr(1);\\n\\n  function trim(arr) {\\n    var start = 0;\\n    for (; start < arr.length; start++) {\\n      if (arr[start] !== '') break;\\n    }\\n\\n    var end = arr.length - 1;\\n    for (; end >= 0; end--) {\\n      if (arr[end] !== '') break;\\n    }\\n\\n    if (start > end) return [];\\n    return arr.slice(start, end - start + 1);\\n  }\\n\\n  var fromParts = trim(from.split('/'));\\n  var toParts = trim(to.split('/'));\\n\\n  var length = Math.min(fromParts.length, toParts.length);\\n  var samePartsLength = length;\\n  for (var i = 0; i < length; i++) {\\n    if (fromParts[i] !== toParts[i]) {\\n      samePartsLength = i;\\n      break;\\n    }\\n  }\\n\\n  var outputParts = [];\\n  for (var i = samePartsLength; i < fromParts.length; i++) {\\n    outputParts.push('..');\\n  }\\n\\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\\n\\n  return outputParts.join('/');\\n};\\n\\nexports.sep = '/';\\nexports.delimiter = ':';\\n\\nexports.dirname = function(path) {\\n  var result = splitPath(path),\\n      root = result[0],\\n      dir = result[1];\\n\\n  if (!root && !dir) {\\n    // No dirname whatsoever\\n    return '.';\\n  }\\n\\n  if (dir) {\\n    // It has a dirname, strip trailing slash\\n    dir = dir.substr(0, dir.length - 1);\\n  }\\n\\n  return root + dir;\\n};\\n\\n\\nexports.basename = function(path, ext) {\\n  var f = splitPath(path)[2];\\n  // TODO: make this comparison case-insensitive on windows?\\n  if (ext && f.substr(-1 * ext.length) === ext) {\\n    f = f.substr(0, f.length - ext.length);\\n  }\\n  return f;\\n};\\n\\n\\nexports.extname = function(path) {\\n  return splitPath(path)[3];\\n};\\n\\nfunction filter (xs, f) {\\n    if (xs.filter) return xs.filter(f);\\n    var res = [];\\n    for (var i = 0; i < xs.length; i++) {\\n        if (f(xs[i], i, xs)) res.push(xs[i]);\\n    }\\n    return res;\\n}\\n\\n// String.prototype.substr - negative index don't work in IE8\\nvar substr = 'ab'.substr(-1) === 'b'\\n    ? function (str, start, len) { return str.substr(start, len) }\\n    : function (str, start, len) {\\n        if (start < 0) start = str.length + start;\\n        return str.substr(start, len);\\n    }\\n;\\n\\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(36)))//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzP2RmN2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbi8vICdyb290JyBpcyBqdXN0IGEgc2xhc2gsIG9yIG5vdGhpbmcuXG52YXIgc3BsaXRQYXRoUmUgPVxuICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xudmFyIHNwbGl0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XG4gIHJldHVybiBzcGxpdFBhdGhSZS5leGVjKGZpbGVuYW1lKS5zbGljZSgxKTtcbn07XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///84\\n\")}});","extractedComments":[]}